/**
 * Copyright (c) 2010, Institute of Telematics, University of Luebeck All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer. - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided with the distribution. - Neither the
 * name of the University of Luebeck nor the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package de.uniluebeck.sourcegen;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.HashMap;
import java.util.LinkedList;

import org.slf4j.LoggerFactory;

import de.uniluebeck.sourcegen.c.CFun;
import de.uniluebeck.sourcegen.c.CHeaderFile;
import de.uniluebeck.sourcegen.c.CHeaderFileImpl;
import de.uniluebeck.sourcegen.c.CSourceFile;
import de.uniluebeck.sourcegen.c.CSourceFileImpl;
import de.uniluebeck.sourcegen.c.CppHeaderFile;
import de.uniluebeck.sourcegen.c.CppHeaderFileImpl;
import de.uniluebeck.sourcegen.c.CppSourceFile;
import de.uniluebeck.sourcegen.c.CppSourceFileImpl;
import de.uniluebeck.sourcegen.java.JClass;
import de.uniluebeck.sourcegen.java.JMethod;
import de.uniluebeck.sourcegen.java.JSourceFile;
import de.uniluebeck.sourcegen.java.JSourceFileImpl;
import de.uniluebeck.sourcegen.nature.Nature;

/**
 * Abstract base containing common methods for the language specific workspaces.
 */
public class Workspace {

	/**
	 * Types of Methods, stored in the MethodStore. (see below)
	 * 
	 */
	public static enum MethodType {
		/** Methods of this Type return some kind of type information */
		TYPE_OF_METHOD,
		/** Method of this type process data for transmittig (e.g. serializing, encrypting,...) */
		SEND_METHOD,
		/** Method of this type process data after receiving (e.g. deserializing, decrypting,...) */
		RECEIVE_METHOD
	}

	/**
	 * This class serves as a key in an hashmap for the globalMethodStore in the workspace. it is not used outside of
	 * the Workspace.
	 * 
	 * @author dariush
	 * 
	 */
	protected class WorkspaceMethodStoreKey {
		public Nature domain;

		public String aspect;

		public MethodType type;

		@Override
		public boolean equals(Object o) {
			if (o == null || !(o instanceof WorkspaceMethodStoreKey))
				return false;

			WorkspaceMethodStoreKey o2 = (WorkspaceMethodStoreKey) o;
			if (this.aspect == null || o2.aspect == null)
				return o2.domain.equals(this.domain) && o2.type.equals(this.type);

			return o2.domain.equals(this.domain) && o2.aspect.equals(this.aspect) && o2.type.equals(this.type);
		}
	}

	private final org.slf4j.Logger log = LoggerFactory.getLogger(Workspace.class);

	private LinkedList<SourceFile> sourceFiles = new LinkedList<SourceFile>();

	private static String jPackagePrefix;

	private static Workspace singletonReference;

	/**
	 * Containers, which hold references to many methods generated by Modules.
	 * 
	 * Sometimes finding references to methods generated by other modules cannot be done by Pin.invocationMethod alone.
	 * For these cases (especially WSModule and APIModule) this global "Dictionary" is necessary.
	 */
	private HashMap<WorkspaceMethodStoreKey, JMethod> globalMethodStoreJava = new HashMap<WorkspaceMethodStoreKey, JMethod>();

	private HashMap<WorkspaceMethodStoreKey, CFun> globalMethodStoreC = new HashMap<WorkspaceMethodStoreKey, CFun>();

	private WsSpec spec;

	public static Workspace getInstance() {
		return singletonReference;
	}

	public Workspace(WsSpec spec) {
		Workspace.singletonReference = this;
		this.spec = spec;
	}

	public WsSpec getWsSpec() {
		return spec;
	}

	public void generate() throws Exception {

		Workspace.jPackagePrefix = spec.get(Nature.LANGUAGE_JAVA, WsSpec.KEY_J_PKG_PREFIX, "");

		log.info("Generating " + sourceFiles.size() + " source files.");

		for (SourceFile sF : sourceFiles) {

			String dirString = getDirString(sF);
			String fileString = getFileString(sF);

			// specific stuff for Security Module
			if (fileString.contains("EncryptionHandler")) {
				dirString = dirString + (fileString.substring(17, fileString.indexOf('.')) + "/");
				fileString = "EncryptionHandler" + getFileExtension(sF);
			}

			File dir = new File(dirString);
			File file = new File(dirString + fileString);

			assureDirExists(dir);
			assureFileExists(file);

			log.info("Generating file " + file.getAbsolutePath() + ".");

			BufferedWriter writer = new BufferedWriter(new FileWriter(file));
			writer.write(sF.toString() + "\n");
			log.debug("Sourcecode of " + sF.getFileName() + ":\n");
			log.debug(sF.toString());
			writer.close();

		}
	}

	private void assureDirExists(File dir) throws Exception {
		if (!dir.exists())
			if (!dir.mkdirs())
				throw new Exception("File output directory couldn't be created.");
	}

	private void assureFileExists(File file) throws Exception {
		if (!file.exists())
			if (!file.createNewFile())
				throw new Exception("File couldn't be created.");
	}

	private String getFileString(SourceFile sourceFile) {
		if (sourceFile instanceof JSourceFile)
			return sourceFile.getFileName() + ".java";
		if (sourceFile instanceof CHeaderFile)
			return sourceFile.getFileName() + ".h";
		if (sourceFile instanceof CSourceFile)
			return sourceFile.getFileName() + ".c";
		if (sourceFile instanceof CppHeaderFile)
			return sourceFile.getFileName() + ".hpp";
		return sourceFile.getFileName() + ".cpp";
	}

	private String getFileExtension(SourceFile sourceFile) {
		if (sourceFile instanceof JSourceFile)
			return ".java";
		if (sourceFile instanceof CHeaderFile)
			return ".h";
		if (sourceFile instanceof CSourceFile)
			return ".c";
		if (sourceFile instanceof CppHeaderFile)
			return ".hpp";
		return ".cpp";
	}

	private String getDirString(SourceFile sourceFile) {
		Nature nature = getNature(sourceFile);
		String projectDirString = spec.get(nature, WsSpec.KEY_PROJECTDIR, System.getProperty("user.home"));
		String subDir = spec.get(nature, WsSpec.KEY_PROJECTSUBDIR, "");
		projectDirString = assureTrailingSeparator(projectDirString);
		projectDirString += subDir;
		if (sourceFile instanceof JSourceFile) {
			JSourceFile jSourceFile = (JSourceFile) sourceFile;
			projectDirString = assureTrailingSeparator(projectDirString);
			projectDirString += jPackagePrefix.replace('.', File.separatorChar);
			projectDirString = assureTrailingSeparator(projectDirString);
			projectDirString += jSourceFile.getPackageName().replace('.', File.separatorChar);
		}
		projectDirString = assureTrailingSeparator(projectDirString);
		return projectDirString;
	}

	private String assureTrailingSeparator(String s) {
		return s.endsWith(File.separator) ? s : s + File.separator;
	}

	private Nature getNature(SourceFile sourceFile) {
		if (sourceFile instanceof JSourceFile)
			return Nature.LANGUAGE_JAVA;
		if (sourceFile instanceof CppSourceFile)
			return Nature.LANGUAGE_CPP;
		if (sourceFile instanceof CSourceFile)
			return Nature.LANGUAGE_C;
		return Nature.LANGUAGE_NESC;
	}

	public JSourceFile getJSourceFile(String packageName, String fileName) {
		// check if source file already exists
		for (SourceFile f : sourceFiles)
			if (f instanceof JSourceFile && ((JSourceFile) f).getPackageName().equals(packageName)
					&& ((JSourceFile) f).getFileName().equals(fileName)) {
				log.error("Sourcefile " + fileName + " gibts schon!! SCHLECHT!");
				log.info("Folgende JSourceFiles gibt es:");
				for (SourceFile file : sourceFiles)
					if (file instanceof JSourceFile) {
						log.info("  " + file.getFileName());
					}
				return (JSourceFile) f;
			}
		JSourceFile f = new JSourceFileImpl(packageName, fileName);
		sourceFiles.add(f);
		log.info("Sourcefile " + fileName + " added to workspace");
		return f;
	}

	public CppHeaderFile getCppHeaderFile(String fileName) {

		// check if file is already existing and
		// return instance if so
		for (SourceFile f : sourceFiles)
			if (f instanceof CppHeaderFile && ((CppSourceFile) f).getFileName().equals(fileName))
				return (CppHeaderFile) f;

		// create the new instance since it's not yet existing
		CppHeaderFileImpl file = new CppHeaderFileImpl(fileName);
		sourceFiles.add(file);
		return file;

	}

	public CppSourceFile getCppSourceFile(String fileName) {

		// check if file is already existing and
		// return instance if so
		for (SourceFile f : sourceFiles)
			if (f instanceof CppSourceFile && !(f instanceof CppHeaderFile)
					&& ((CppSourceFile) f).getFileName().equals(fileName))
				return (CppSourceFile) f;

		// create the new instance since it's not yet existing
		CppSourceFile file = new CppSourceFileImpl(fileName);
		sourceFiles.add(file);
		return file;
	}

	public CSourceFile getCSourceFile(String fileName) {

		// check if source file already existing and
		// return instance if so
		for (SourceFile f : sourceFiles)
			if (f instanceof CSourceFile && !(f instanceof CHeaderFile)
					&& ((CSourceFile) f).getFileName().equals(fileName))
				return (CSourceFile) f;

		// create new instance since it's not yet existing
		CSourceFile file = new CSourceFileImpl(fileName);
		sourceFiles.add(file);
		return file;

	}

	public boolean containsCHeaderFile(String fileName) {
		for (SourceFile f : sourceFiles)
			if (f instanceof CHeaderFile && f.getFileName().equals(fileName))
				return true;
		return false;

	}

	public boolean containsCSourceFile(String fileName) {
		for (SourceFile f : sourceFiles)
			if (f instanceof CSourceFile && !(f instanceof CHeaderFile) && f.getFileName().equals(fileName))
				return true;
		return false;
	}

	public boolean containsJavaClass(String clazz) {
		for (SourceFile f : sourceFiles) {
			if (f instanceof JSourceFile) {
				JSourceFile file = (JSourceFile) f;
				JClass jclazz = file.getClassByName(clazz);
				if (jclazz != null) {
					return true;
				}
			}
		}
		return false;
	}

	public CHeaderFile getCHeaderFile(String filename) {

		// check if source file already existing and
		// return instance if so
		for (SourceFile f : sourceFiles)
			if (f instanceof CHeaderFile && f.getFileName().equals(filename))
				return (CHeaderFile) f;

		// create new instance since it's not yet existing
		CHeaderFileImpl header = new CHeaderFileImpl(filename);
		sourceFiles.add(header);

		try {

			// adding header include guard (part 1)
			String guard = filename.toUpperCase() + "_H";
			header.addBeforeDirective("ifndef " + guard);
			header.addBeforeDirective("define " + guard);

			// adding the extern "C" directive
			header.addBeforeDirective("if defined __cplusplus");
			header.addBeforeDirective(false, "extern \"C\" {");
			header.addBeforeDirective("endif");
			header.addAfterDirective("if defined __cplusplus");
			header.addAfterDirective(false, "}");
			header.addAfterDirective("endif");

			// belongs to the header include guard
			header.addAfterDirective("endif");

		} catch (Exception e) {
			log.error("" + e, e);
			e.printStackTrace();
		}

		return header;

	}

	public static String getJPackagePrefix() {
		return jPackagePrefix;
	}

	/**
	 * Stores a new method in the store
	 * 
	 * @param domain
	 * @param aspect
	 * @param type
	 * @return
	 */
	public void setGlobalMethod(Nature domain, String aspect, MethodType type, JMethod method) {
		WorkspaceMethodStoreKey key = new WorkspaceMethodStoreKey();
		key.aspect = aspect;
		key.domain = domain;
		key.type = type;

		globalMethodStoreJava.put(key, method);
	}

	/**
	 * Stores a new method in the store
	 * 
	 * @param domain
	 * @param aspect
	 * @param type
	 * @return
	 */
	public void setGlobalMethod(Nature domain, String aspect, MethodType type, CFun fun) {
		WorkspaceMethodStoreKey key = new WorkspaceMethodStoreKey();
		key.aspect = aspect;
		key.domain = domain;
		key.type = type;

		globalMethodStoreC.put(key, fun);

	}

	/**
	 * Returns a Method from the store.
	 * 
	 * @param domain
	 * @param aspect
	 * @param type
	 * @return
	 */
	public CFun getGlobalMethodC(Nature domain, String aspect, MethodType type) {
		WorkspaceMethodStoreKey key = new WorkspaceMethodStoreKey();
		key.aspect = aspect;
		key.domain = domain;
		key.type = type;

		for (WorkspaceMethodStoreKey k : globalMethodStoreC.keySet()) {
			if (k.equals(key))
				return globalMethodStoreC.get(k);
		}

		return null;
	}

	/**
	 * Returns a Method from the store.
	 * 
	 * @param domain
	 * @param aspect
	 * @param type
	 * @return
	 */
	public JMethod getGlobalMethodJava(Nature domain, String aspect, MethodType type) {
		WorkspaceMethodStoreKey key = new WorkspaceMethodStoreKey();
		key.aspect = aspect;
		key.domain = domain;
		key.type = type;

		for (WorkspaceMethodStoreKey k : globalMethodStoreJava.keySet()) {
			if (k.equals(key))
				return globalMethodStoreJava.get(k);
		}

		return null;
	}

}
